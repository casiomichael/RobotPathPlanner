# Multi-Robot Path Planner
## Running the Project
To run the project, Jupyter is needed, since all files are Jupyter .ipynb files. 
## Algorithm Overview
There are many scenarios in which robots can be in a deadlock given a certain grid, obstacles in the grid, positioning of start and end positions of robots, etc. To tackle the problem of avoiding this deadlock such that robots don't try to go to the same cell at the same time, or collide with one another when it is in a 2x2 square, we first look into generating a path for each individual robot, without regard of future collisions.

To generate a single-robot path, we use breadth-first search (BFS), which essentially checks surrounding cells to see if it is a valid move, and generate a path from there. In my particular BFS algorithm, we first check to see if the cell below the current cell is valid (i.e. it is within the grid and there is no obstacle), followed by a check to the cell to its right, then above, then to its left. The nodes that are valid are then appended to a "possible path" and then appended to a queue in which we will check to see if we have reached a path that gets us from start to end. The order in which we check cells around the robot's current cell (i.e. down, right, up, left) is completely arbitrary and is defined by the user as they wish. No particular order gives more of an advantage as another, as BFS will generate the shortest path regardless of order of surrounding cell checks. The primary reason why BFS was chosen as a path planning algorithm rather than Dijkstra's is because of the problem statement. Dijkstra's algorithm is a glorified BFS in that its main difference is that Dijkstra's takes into account of weighted nodes. However, since the problem statement is a grid in which each "node" is weighted evenly, it is not necessary to use Dijkstra's. A benefit of not using Dijkstra's is the fact that BFS runs faster than Dijkstra's since it doesn't need to keep track of the weights of each node/path. A visual for how BFS works is seen in Figure 1.

After generating a single-path for each robot, we now need to take into account of possible intersections between these individual paths. For example, there can be a scenario in which these robot paths go into a hallway and would require some robots to wait for other robots to proceed before they themselves can go. This scenario is seen in Figure 2. If the robots on the left were to try to get to the top right, while the robots on the right are trying to get to the top left, one solution to this problem would be to move the robots one at a time to its desired position. Each individual robot path can be executed one a time, and would only proceed to executing the next robot's path when the current robot has arrived at its destination. However, this isn't efficient and is not practical in the real world. Instead, robots can move together at the same time while participating in some form of compromise (i.e. a give-and-take system in which some robots pause and let the other robots pass).

Another scenario could be one in which two robot's paths require going to the same cell at the same time step. This scenario is seen in Figure 3. In this scenario, the robot in the middle is trying to get to the right side of the grid, while the robot at the right is just trying to go down. At its current state, they are not colliding, but after two time steps, the robots will try to get to the same cell at the same time. One robot would need to wait and let the other pass before proceeding. If they moved to the same cell at the same time step, then the robots would collide.  There are two ways to solve this problem: the first is to have one robot wait, while the other passes. The second way to solve this problem is to reroute one of the robots to another path. The former solution was chosen, as rerouting the robot would require another calculation of BFS, which is inefficient and more complex than staying at the same position for a few time steps until the robot has passed.

Another scenario in which would cause robots to be in a deadlock is if they were put in a 2x2 cell. This scenario is seen in Figure 4. There are four potential scenarios that could happen if two robots were in a 2x2 cell. Three of them are depicted, while the fourth is not. The first scenario, as seen in the left side of Figure 3, is when robots are in opposite corners and both just need to go straight. There are no necessary moves that need to be added. The robots will never intersect each other, thus we can continue on the path that BFS generated for us. The second scenario, seen in the middle of Figure 4, is if the two robots are in opposite corners and they need to swap paths. This is a problem because if their initial paths both went through the bottom right corner, then that would cause a collision. This is solved by a function, exchange2x2, which essentially generates a path for both robots such that they won't collide. The third scenario is similar to that of the second, except the robots are not on opposite corners, but both on one side. Again, exchange2x2 handles a path that can be appended to our path such that a scenario of this collision is avoided. The fourth scenario, which is not depicted, is the scenario in which two robots are in a 2x2 scenario, but one, or both, of the robot's next desired cell is outside of the 2x2 cell. This is handled through a simple wait (i.e. let the robot going out of the 2x2 pass, before proceeding). These would not intersect since they have disjoint next desired cells.

## Algorithm Implementation
As mentioned in the previous subsection, we handle these potential deadlocks through "waits," where a robot lets the other pass before it proceeds, or through appending a new path that was generated for 2x2 scenarios, before proceeding to the next step in the path initially generated by BFS. 

In the implementation of the algorithm described in the previous subsection, a path is first generated through BFS. This is set as the model for which the robots must follow. This is the indivRobotPaths variable in the pathgen function. This was designed so that multiple calls to BFS wouldn't be necessary, thus prevent an increase in run time and complexity. This model is in a list of lists (i.e. the pathgen function, which generates the final path that we execute (that already takes into account of possible collisions). The first tuple (a coordinate) is popped into an array that would represent the current coordinate in which the robot is in. The second tuple is also popped into an array, but would represent the next-desired cell. This will later be used for predicting if robots need to pause. We compare each time step and check to see if there are matching coordinates, or if there are 2x2 scenarios at certain time steps. If there were no conflicts found with the next step, whether it be robots moving into the same cell or if robots end up in a 2x2 scenario, then the current coordinates are appended to the final list of paths that we will return. Each index in the list of paths represent the path of a robot. 

If the next desired cell for two robots were the same, then a "wait" is instituted to a robot. This robot was picked arbitrarily, but ideally the robot that would wait is the robot that is closer to its end position. If more time and a better grasp of coding in Python were available, then this would have been implemented by having a constant calculation of the Manhattan distance between a robot and its target cell. In the ideal scenario, the robot that had a lower Manhattan distance would be the one to wait, to reduce run time.

If the next desired cell for each robot puts the, in a 2x2 scenario, a path generated by exchange2x2 is appended to the final path generated. The next step would then be to run the checks between time step again, for the next desired step in indivRobotPaths.

An case that happens often is a robot that arrives at its desired position before others arrive at its desired position. In this case, "waits" are instituted by telling the robot to just stay at its current position.

## Theoretical Behavior
A possible scenario is that multiple robots can be experiencing conflicts at a certain time step. For example, there could be two robots that are about to move to the same cell at the left side of the grid, but there are also two robots on the right side of the grid that are in a 2x2 exchange. Truthfully, I haven't fully tested this scenario, so I cannot say with absolutely certain how this handles it realistically, but the way that it is currently structured in code is that it handles all issues with robots moving to the same cell first (i.e. the matches check in pathgen is done first), then it handles cases where robots are in a 2x2 scenario. 

With certainty, I am able to say that non-conflicting robots are allowed to move while conflicting robots are moving. This is handled through the popping of each current time step, and adding that to the final path, as described above. 

As mentioned above, when there is the case that two robots on a single time step are approaching the same cell along their individual paths, pathgen handles this by issuing a wait for one of the robots. This prevents this collision since one of the robots proceed to through their path while the other robot waits, and then proceeds as it realizes it is clear. The way this is handle is through an analysis of the next desired step. If the next desired steps for two robots match, then one robot is told to stay at its current position (by appending the current position to its final path), while the other robot is allowed to proceed to its next desired cell.

The planner takes in a few necessary inputs: the starting and end positions of robots, and obstacle locations. This is all that's necessary because of the fact that the internal methods take care of initial path generation (bfs), and dynamically changing such path to avoid conflict such as moving into the same cell, or having to add additional moves to satisfy the 2x2 exchange.

The planner assumes conditions such as that no robot start or end at the same position, and that there are no scenarios in which a robot has to go through a hallway that is only one cell wide. This would require robots backing up or waiting at its entrance/exit while the other robot moves through. This was not considered because of the complexity of this problem. Another assumption for this planner is that robots do not start or end next to each other. This could have been an easy fix (i.e. making cells that contain robots invalid nodes in validAdjacentNodes). However, I ran out of time, which is why I wasn't able to implement it. If robots start or end next to each other or next to a robot's path, then the planner at its current state interprets the cell that is occupied by a robot as valid, and thus will try to move there. 

The performance qualities of this planner is that it is an optimal planner, since it terminates in finite time, and computes the optimal path, if one exists. However, a limitation of this planner is that it considers conflicts such as the robot cell not being considered as an invalid node as not a conflict. This goes against what an optimal planner is since it just terminates the path generation if it comes across that problem, when in reality, a path does exist, it's just a conflict that was not implemented to be handled. Furthermore, this planner could have been a complete planner if the BFS method was altered such that an exception or statement that says "no path found!" if the robot tried to go to an invalid position (i.e. another robot's start position, outside of the grid, into an obstacle, etc.) With that being said, Figure 5 shows a successful run of the scenario in Figure 3, in which a wait was called and the robot in the far right is allowed to proceed before the middle robot.
